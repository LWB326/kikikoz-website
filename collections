note  : traduction de la notice Grav chap 2 section Collections MF
#Collections de pages

Le nomnbre de collections a considérablement augmenté depuis les débuts de Grav. Nous avons commencé avec un jeu très limité de collections basées sur des pages, mais avec l'aide de notre communauté, nous avons augmenté leurs capacités pour les rendre encore plus puissantes! À tel point qu'ils ont maintenant leur propre section dans la documentation.

##Collections fondamentales de Grav

Dans Grav, le type de collection le plus courant est une liste de pages qui peuvent être définies soit dans le front-matter de la page, soit dans le twig lui-même. Le plus courant est de définir une collection dans le front-matter. Une fois la collection définie, elle est disponible à la deùande dans le Twig  de la page en cours. En utilisant des méthodes de collecte de page ou en bouclant chaque objet-page et en utilisant les méthodes ou les propriétés de la page, vous pouvez faire des choses puissantes. Des exemples classiques de cela incluent l'affichage d'une liste de messages de blog ou l'affichage de sous-pages modulaires pour permettant la conception de pages complexes.

##Objet de collection

Lorsque vous définissez une collection dans l'en-tête (header) de la page, vous créez dynamiquement une *Collection Grav* disponible dans le Twig de la page. Cet objet-Collection est *itératif* et peut être traité comme un *tableau*(array) vous permettant de faire des choses telles que:

{{ dump(page.collection[page.path]) }}
 

##Exemple de définition de la collection

Un exemple de collection définie dans le front-matter de la page:

 
content: items: '@self.children' order: by: date dir: desc limit: 10 pagination: true
 

Dans le frontmatter de la page, content.items indique à Grav comment la collection doit être construite en rassemblant les éléments et informations qui ont été passés.

Cet exemple de définition crée une collection pour la page concernée, composée de toutes les **pages enfants** classées par **date décroissante** avec une **pagination** montrant **10 éléments** par page.

##Accès aux Collections en Twig

Lorsque cette collection est définie dans l'en-tête, Grav crée une collection **page.collection** à laquelle vous pouvez accéder depuis un template de twig avec :

 
{% for p in page.collection %} <h2>{{ p.title }}</h2> {{ p.summary }} {% endfor %}
 

Cela *boucle* simplement les pages de la collection et affiche le titre et le résumé.

##En-têtes de collection

Un certain nombre de variables peuvent être utilisées afin d'indiquer à Grav que la page spécifique doit être une page de listes et contenir des pages-enfants :


##Résumé des options de collection

Chaîne 							Résultat
'@racine' 						Obtenir les enfants de la racine 
'@ Root.children' 				Obtenir les enfants de la racine(alternative)
'@ Root.descendants' 			Obtenir les enfants de la racine de façon récursive TOUS les enfants
	
'@ Self.parent' 				Obtenir la page-parent de la page actuelle
'@ Self.siblings' 				Une collection de toutes les autres pages à ce niveau
'@ Self.modular' 				Obtenir uniquement les enfants modulaires
'@ Self.children' 				Obtenir les enfants non-modulaires
'@ Self.descendants' 			Obtenir de façon récursive les enfants non-modulaires
	
'@page': '/ fruit' 				Obtenir tous les enfants de la page /fruit
'@ Page.children': '/ fruit' 	Variante du précédent
'@ Page.self': '/ fruit' 		Obtenir une collection avec seulement la page /fruit
'@ Page.page': '/ fruit' 		Variante du précédent
'@ Page.descendants': '/ fruit' Obtenir de façon récursive tous les enfants de la page /fruit
'@ Page.modular': '/ fruit' 	Obtenir une collection de toutes les sous-pages modulaires de /fruit
	
'@ Taxonomy.tag': photographie 	Taxonomie avec tag = photography
'@taxonomy': {tag: birds, category: blog} 	Taxonomie avec tag = birds && category = blog

Note
Ce document décrit l'utilisation de @page , @taxonomy.category etc., mais un format alternatif plus sûr de YAML est page@ , taxonomy@.category . Toutes les commandes @ peuvent être écrites au format préfixe ou postfix.

Nous aborderons cela plus en détail. 

##Collections de racine

@root - Enfants du niveau supérieur

Peut être utilisé pour récupérer les enfants non modulaires **publiés** du niveau supérieur/de la racine d'un site. C'est particulièrement utile pour obtenir les éléments  composant la navigation principale par exemple :

 
content: items: '@root'
 

Un alias est également valable :

 
content: items: '@root.children'
 

@root - Enfants du niveau supérieur + tous les descendants

Cela permettra d'atteindre par une navigation récursive toutes les pages de votre site, en descendant à partir de la page racine, en créant une collection de **tous** les **enfants non-modulaires publiés**.

 
content: items: '@root.descendants'
 

##Self Collections
@ Self.children - Enfants de la page courante

Permet d'énumérer les enfants non-modulaires publiés de la page actuelle:

 
content: items: '@self.children'
 

@ Self.descendants - Enfants non-modulaires + tous les descendants de la page courante

À l'instar de .children , la collection .descendants retrouve tous les **enfants non-modulaires publiés**, mais poursuit de façon récursive à travers tous ses enfants.

 
content: items: '@self.descendants'
 

@ Self.modular - Enfants modulaires de la page courante

A l'inverse de .children , cette méthode récupère uniquement les **enfants modulaires publiés** de la page actuelle ( _features , _showcase , etc.)

 
content: items: '@self.modular'
 

@self.parent - La page-parent de la page courante

Il s'agit d'une collection spéciale, car il retournera toujours uniquement **premier** parent  de la page actuelle

 
content: items: '@self.parent'
 

@self.siblings - Toutes les pages frères et soeurs

Cette collection rassemblera toutes les pages publiées au même niveau que celui de la page courante, à l'exclusion de la page courante.

 
content: items: '@self.siblings'
 

##Collections de pages

@page ou @page.children - Collection d'enfants d'une page spécifique

Cette collection prend en argument le slug d'une page  et renvoit tous les enfants non modulaires publiés de cette page

 
content: items: '@page': '/blog'
 

En variante:

 
content: items: '@page.children': '/blog'
 

@page.self ou @page.page - Collection de la seule page spécifique

Cette collection prend comme argument le slug d'une page  et renvoie la collection contenant cette page (si elle est **ubliée et non-modulaire** )

 
content: items: '@page.self': '/blog'
 

@page.descendants - Collection d'enfants + tous les descendants d'une page spécifique

Cette collection prend comme argument le slug d'une page et renvoit tous les enfants **non-modulaires publiés** et tous leurs descendants de cette page

 
content: items: '@page.descendants': '/blog'
 

@page.modular - Collection d'enfants modulaires d'une page spécifique

Cette collection prend comme argument le slug d'une page et renvoit tous les enfants **modulaires publiés** de cette page

 
content: items: '@page.modular': '/blog'
 

##Collections de taxonomie

 
content: items: '@taxonomy.tag': foo
 

En utilisant l'option @taxonomy , vous pouvez utiliser la puissance de la fonctionnalité de taxonomie de Grav. C'est là que la variable de taxonomy du fichier de configuration du site entre en jeu. La taxonomie **doit** être définie dans ce fichier de configuration pour que Grav puisse interpréter une référence de page comme valide.

En configurant @taxonomy.tag: foo , Grav trouve toutes les **pages publiées** dans le dossier /user/pages qui comportent le tag: foo dans leur variable de taxonomie.

 
content: items: '@taxonomy.tag': [foo, bar]
 

La variable content.items peut prendre la forme  d'un tableau de taxonomies et qui rassemble toutes les pages qui satisfont ces règles. Les pages publiées possédant **à la fois** les étiquettes foo et bar seront collectées. Le chapitre sur la *Taxonomie* abordera plus en détails ce concept.

Info
Si vous souhaitez placer plusieurs variables en ligne, vous devez séparer les sous-variables d'avec leurs parents avec des parenthèses {}. Vous pouvez ensuite séparer entre-elles les variables individuelles de ce niveau avec une virgule. Par exemple: @taxonomy: {category: [blog, featured], tag: [foo, bar]} . Dans cet exemple, les sous-variables category et tag sont placées dans la hiérarchie @taxonomy, chacune avec des valeurs indiquées entre parenthèses []. Les pages doivent respecter toutes ces conditions.

Si vous avez plusieurs variables dans un parent unique, vous pouvez le faire en utilisant la méthode en ligne, mais pour simplifier, nous vous recommandons d'utiliser la méthode standard. Voici un exemple.

 
content: 
	items:
	'@taxonomy':
		category: [blog, featured] 
		tag: [foo, bar]
 

Chaque niveau dans la hiérarchie ajoute deux espaces blancs avant la variable. YAML vous permettra d'utiliser autant d'espaces que vous le souhaitez ici, mais deux est une pratique standard. Dans l'exemple ci-dessus, les variables category et tag sont définies sous @taxonomy .

##Collections complexes

Grav 0.9.41 vous permet d'utiliser plusieurs définitions de collection complexes et la collection résultante sera la somme de toutes les pages trouvées avec chacune des définitions de collection.

par exemple:

 
content: 
	items: 
		- '@self.children' 
		- '@taxonomy': 
			category: [blog, featured]


##Options de tri

 
content: 
	order: 
		by: date 
		dir: desc 
	limit: 5 
	pagination: true
 

L'ordre des sous-pages suit les mêmes règles de tri que son dossier, les options disponibles sont:

Commande 			Détails
défaut 				Ordre basé sur celui du système de fichiers, 						c'est-à-dire 01.home avant 02.advark
titre 				Ordre basé sur le titre tel que défini dans 					chaque page
basename			Ordre basé  sur le nom alphabétique du dossier 						après qu'il a été traité par la fonction PHP 					basename()
date		 		Ordre basé sur la date telle que définie dans 				chaque page
modifies 		Ordre basé sur le timsestamp modifié de la page
dossier 		Ordre basé sur le nom du dossier avec n'importe 			quel préfixe numérique, c'est-à-dire 01. supprimé
header.x 		Ordre basé sur n'importe quel champ d'en-tête de 					page. Par ex. header.taxonomy.year . De plus, une valeur par défaut peut être ajoutée via un pipe. C'est-à-dire header.taxonomy.year|2015
manuel 			Ordre basé sur la variable order_manual
random 			Ordre est randomisé
custom 			Ordre est basé sur la variable content.order.custom
sort_flags 		Permet de passer outre les indicateurs de tri par 				définis dans le header d'une page ou définis par 					défaut. Si l'extension PHP intl  est chargée, 					**seules ces étiquettes** sont disponibles. Sinon, 				vous pouvez utiliser les **étiquettes de tri standard PHP**.

La variable content.order.dir contrôle la direction du tri. Les valeurs valides sont soit desc ou asc .

 
content: 
	order: 
		by: default 
			custom: 
				- _showcase 
				- _highlights 
				- _callout
				- _features 
		limit: 5 
		pagination: true
 

Dans la configuration ci-dessus, vous pouvez voir que content.order.custom est la définition d'une **commande manuelle personnalisée** permettant de construire la page avec en premier le **showcase**, la section **highlights** en deuxième, etc. Veuillez noter que si une page n'est pas spécifiée dans la liste de commande personnalisée, alors Gravse base sur le content.order.by pour les pages non spécifiées.

Si une page comporte un slug personnalisé, vous devez utiliser ce slug dans la liste content.order.custom.

Le content.pagination est une simple étiquette booléene utilisée par les plugins, etc. pour savoir si la **pagination** doit être initialisée pour cette collection. content.limit est le nombre d'éléments affichés par page lorsque la pagination est activée.


##Plage de dates

Nouveau, à partir de Grav 0.9.13 il est possible de filtrer sur une plage de dates :

 
content: 
	items: '@self.children' 
	dateRange: 
		start: 1/1/2014 
		end: 1/1/2015
 

Vous pouvez utiliser n'importe quel format de chaîne de date  supporté par *strtotime()* comme -6 weeks ou last Monday , ainsi bien que des dates plus traditionnelles telles que le 01/23/2014 ou le 23 January 2014. dateRange va filtrer les pages ayant une date en dehors de la date fournie. fournir les deux dates de début et de fin est facultatif, mais au moins une doit être fournie.


##Collections multiples

Lorsque vous créez une collection avec content: items: dans votre YAML, vous définissez une seule collection baséee sur plusieurs conditions. Toutefois, Grav vous permet de créer un ensemble arbitraire de collections par page, il vous suffit de créer un autre:

 
content: 
	items: '@self.children' 
	order: 
		by: date 
		dir: desc 
	limit: 10 
	pagination: true 
	
fruit: 
	items: '@taxonomy.tag': [fruit]
 

Ceci définit **2 collections** pour cette page, la première utilise la collection par défaut content, mais la seconde définit une collection basée sur la taxonomie appelée fruit. Pour accéder à ces deux collections via Twig, vous pouvez utiliser la syntaxe suivante :

 
{% set default_collection = page.collection %} 
{% set fruit_collection = page.collection('fruit') %}
 

Méthodes  d'objets de collection

Méthodes standard itérables , les méthodes intéressantes comprennent:

    Collection::append($items) - Ajouter une autre collection ou tableau
    Collection::first() - Obtenir le premier élément de la collection
    Collection::last() - Obtenir le dernier élément de la collection
    Collection::random($num) - Choisissez aléatoirement $num articles  de la collection
    Collection::reverse() - Inverser l'ordre de la collection
    Collection::shuffle() - Randomise la collection entière
    Collection::slice($offset, $length) - Découpe de la liste 

Il existe également plusieurs méthodes utiles spécifiques de la collection:

    Collection::addPage($page) - Vous pouvez ajouter une autre page à cette collection.
    Collection::copy() - Crée une copie de la collection courante
    Collection::current() - Atteint l'élément courant dans la collection
    Collection::key() - Renvoie le slug courant de l'élément courant
    Collection::remove($path) - Supprime une page spécifique dans la collection, ou la page courante si $path = null
    Collection::order($by, $dir, $manual) - Trie la collection courante
    Collection::isFirst($path) - Détermine si la page identifiée par chemin d'accès la première
    Collection::isLast($path) - Détermine si la page identifiée par chemin est la dernière
    Collection::prevSibling($path) - Renvoie la page précédente de la fratrie si possible
    Collection::nextSibling($path) - Renvoie la page de suivante de la fratrie si possible
    Collection::currentPosition($path) - Renvoie l'indice courant
	Collection::dateRange($startDate, $endDate, $field) - Filtre la collection courante avec les dates
    Collection::visible() - Filtre la collection courante pour inclure uniquement les pages visibles
    Collection::nonVisible()  - Filtre la collection courante pour inclure uniquement les pages non visibles
    Collection::modular() - Permet de filtrer la collection courante pour inclure uniquement des pages modulaires
    Collection::nonModular() - Filtre la collection courante pour inclure uniquement des pages non-modulaires
    Collection::published() - Filtre la collection courante pour inclure uniquement les pages publiées
    Collection::nonPublished() - Filtre la collection courante pour inclure uniquement les pages non publiées
    Collection::routable() - Filtre la collection courante pour inclure uniquement les pages routables
 	Collection::nonRoutable() - Filtre la collection courante pour inclure uniquement les pages non-routables
  	Collection::ofType($type) - Filtre la collection courante pour inclure uniquement les pages où template = $type 
    Collection::ofOneOfTheseTypes($types)  - Filtre la collection courante pour inclure uniquement les pages dont le modèle est dans le tableau $types
    Collection::ofOneOfTheseAccessLevels($levels)  - Filtre la collection courante pour inclure uniquement les pages dont la page d'accès se  trouve dans le tableau $levels 

Voici un exemple tiré du docs.html.twig du thème **Learn2** qui définit une collection basée sur la taxonomie (et éventuellement des balises si elles existent) et utilise les méthodes Collection::isFirst et Collection::isLast pour ajouter de manière conditionnelle une page la navigation :

 
{% set tags = page.taxonomy.tag %} 
{% if tags %} {% set progress = page.collection({'items':{'@taxonomy':{'category': 'docs', 'tag': tags}},'order': {'by': 'default', 'dir': 'asc'}}) %} {% else %} {% set progress = page.collection({'items':{'@taxonomy':{'category': 'docs'}},'order': {'by': 'default', 'dir': 'asc'}}) %} {% endif %} {% block navigation %} <div id="navigation"> {% if not progress.isFirst(page.path) %} <a class="nav nav-prev" href="{{ progress.nextSibling(page.path).url }}"> <i class="fa fa-chevron-left"></i></a> {% endif %} {% if not progress.isLast(page.path) %} <a class="nav nav-next" href="{{ progress.prevSibling(page.path).url }}"><i class="fa fa-chevron-right"></i></a> {% endif %} </div> {% endblock %}
 

nextSibling() est en haut de la liste et prevSibling() est en bas de la liste, voici comment cela fonctionne :

 
En supposant que vous avez les pages:
	Projet A
	Projet B
	Projet C 
Vous êtes sur le Projet A, la page précédente est le Projet B.
Si vous êtes sur le Projet B, la page précédente est le Projet C et la suivante est Projet A
 

##Collections programmatiques

Vous pouvez prendre le contrôle total des collections directement en PHP, depuis les plugins Grav, les thèmes ou même Twig. Il s'agit d'une approche codée plus strictement que la définition de votre page de référence, mais elle permet une logique de collections plus complexe et flexible.

##Collections PHP

Vous pouvez effectuer une collection logique avancée avec PHP, par exemple:

 
$collection = new Collection(); 
$collection->setParams(['taxonomies' => ['tag' => ['dog', 'cat']]])->dateRange('01/01/2016', '12/31/2016')->published()->ofType('blog-item')->order('date', 'desc'); 
$titles = []; 
foreach ($collection as $page) {
$titles[] = $page->title(); 
}
 

Vous pouvez également utiliser la même méthode evaluate() que celle utilisée par les collections de pages basées sur le  frontmatter:

 
$page = Grav::instance()['page']; $collection = $page->evaluate(['@page.children' => '/blog', '@taxonomy.tag' => 'photography']); $ordered_collection = $collection->order('date', 'desc');
 

Vous pouvez également le faire directement dans **Twig Templates** :

 
{% set collection = page.evaluate([{'@page.children':'/blog', '@taxonomy.tag':'photography'}]) %} {% set ordered_collection = collection.order('date','desc') %}
 

##Collections avancées

Par défaut, lorsque vous appelez page.collection() dans le Twig qui possède une collection définie dans le header, Grav recherche une collection appelée content. Cela permet de définir *plusieurs collections* , mais vous pouvez cependant aller plus loin.

Si vous devez générer une collection de façon programmatique, vous pouvez le faire en appelant page.collection() et en passant dans un tableau du même format que la définition de collection du header de page. Par exemple:

 
{% set options = { items: {'@page.children': '/my/pages'}, 'limit': 5, 'order': {'by': 'date', 'dir': 'desc'}, 'pagination': true } %} {% set my_collection = page.collection(options) %} <ul> {% for p in my_collection %} <li>{{ p.title }}</li> {% endfor %} </ul>
 

